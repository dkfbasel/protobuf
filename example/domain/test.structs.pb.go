// Code generated by protoc-gen-gotags. DO NOT EDIT.
// source: test.proto

/*
Package t1 is a generated protocol buffer package.

It is generated from these files:
	test.proto

It has these top-level messages:
	TestRequest
	TestNested
	TestResponse
*/
package t1

import protodef "bitbucket.org/dkfbasel/dev.grpc-tags/proto_test/proto"
import fmt "fmt"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf

// TestRequest is used to do request a test run
type TestRequest struct {
	// some information
	Name           string `custom:"name"` // some additional comment
	Function       int32  // custom:"function"
	TestNested     `compose:"embed"`
	SubItemNested  *TestNested   // another function
	SubItemsNested []*TestNested // another function
}

// TestNested ...
type TestNested struct {
	Name     string `custom:"nested-name" db:"test" json:"joo,omitempty"`
	Function string
}

// TestResponse ...
type TestResponse struct {
	// status will return the sending status: ok
	// if sending fails, an error will be returned
	Status []string // @keep-this this would be awesome
}

// --- STRUCT CONVERSION ---

// Convert will convert the proto struct to a custom type with
// tags and embedded structs if specified
func (from *TestRequest) Convert() (*protodef.TestRequest, error) {
	var err error

	if from == nil {
		return nil, nil
	}

	to := protodef.TestRequest{}

	to.Name = from.Name

	to.Function = from.Function

	to.SubItemEmbeded, err = from.TestNested.Convert()
	if err != nil {
		return nil, err
	}

	to.SubItemNested, err = from.SubItemNested.Convert()
	if err != nil {
		return nil, err
	}

	if from.SubItemsNested != nil {
		to.SubItemsNested = make([]*protodef.TestNested, len(from.SubItemsNested))
		for i := range from.SubItemsNested {
			to.SubItemsNested[i], err = from.SubItemsNested[i].Convert()
			if err != nil {
				return nil, err
			}
		}
	}

	return &to, err
}

// Convert will convert the proto struct to a custom type with
// tags and embedded structs if specified
func (from *TestNested) Convert() (*protodef.TestNested, error) {
	var err error

	if from == nil {
		return nil, nil
	}

	to := protodef.TestNested{}

	to.Name = from.Name

	to.Function = from.Function

	return &to, err
}

// Convert will convert the proto struct to a custom type with
// tags and embedded structs if specified
func (from *TestResponse) Convert() (*protodef.TestResponse, error) {
	var err error

	if from == nil {
		return nil, nil
	}

	to := protodef.TestResponse{}

	if from.Status != nil {
		to.Status = make([]string, len(from.Status))
		for i := range from.Status {
			to.Status[i] = from.Status[i]
		}
	}

	return &to, err
}

// ConvertTestRequest will convert the proto optimized struct into
// an easier to use go structs
func ConvertTestRequest(from *protodef.TestRequest) (*TestRequest, error) {
	var err error

	if from == nil {
		return nil, nil
	}

	to := TestRequest{}

	to.Name = from.GetName()

	to.Function = from.GetFunction()

	tmp, err := ConvertTestNested(from.GetSubItemEmbeded())
	if err != nil {
		return nil, err
	}
	to.TestNested = *tmp

	to.SubItemNested, err = ConvertTestNested(from.GetSubItemNested())
	if err != nil {
		return nil, err
	}

	if from.GetSubItemsNested() != nil {
		to.SubItemsNested = make([]*TestNested, len(from.SubItemsNested))
		for i := range from.SubItemsNested {
			to.SubItemsNested[i], err = ConvertTestNested(from.SubItemsNested[i])
			if err != nil {
				return nil, err
			}
		}
	}

	return &to, err
}

// ConvertTestNested will convert the proto optimized struct into
// an easier to use go structs
func ConvertTestNested(from *protodef.TestNested) (*TestNested, error) {
	var err error

	if from == nil {
		return nil, nil
	}

	to := TestNested{}

	to.Name = from.GetName()

	to.Function = from.GetFunction()

	return &to, err
}

// ConvertTestResponse will convert the proto optimized struct into
// an easier to use go structs
func ConvertTestResponse(from *protodef.TestResponse) (*TestResponse, error) {
	var err error

	if from == nil {
		return nil, nil
	}

	to := TestResponse{}

	if from.Status != nil {
		to.Status = make([]string, len(from.Status))
		for i := range from.Status {
			to.Status[i] = from.Status[i]
		}
	}

	return &to, err
}
