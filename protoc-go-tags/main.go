package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func main() {

	var directory string
	flag.StringVar(&directory, "dir", ".", "directory to search for pb files")
	flag.Parse()

	filepathErr := filepath.Walk(directory, func(path string, info os.FileInfo, err error) error {

		if err != nil {
			return err
		}

		// ignore all files that have not been generated by pb
		if strings.HasSuffix(path, ".pb.go") == false {
			return nil
		}

		err = addGoTags(path)

		if err != nil {
			log.Printf("%s: %v\n", path, err)
		}

		return err

	})

	if filepathErr != nil {
		log.Printf("could not correctly handle directory: %v", filepathErr)
	}

}

// addGoTags will add specifically defined tags to the go protobuf structs
func addGoTags(path string) error {

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("could not parse go file: %v", err)
	}

	var visitor visitor
	ast.Walk(visitor, node)

	f, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("could not open output file: %v", err)
	}
	defer f.Close() // nolint: errcheck

	err = format.Node(f, fset, node)
	if err != nil {
		return fmt.Errorf("could not write output file: %v", err)
	}

	return nil

}

// define a visitor struct to handle every ast node
type visitor struct{}

// Visit will find all fields in the code and add tags that are placed
// in the comment above the field as struct tags to the field
func (v visitor) Visit(n ast.Node) ast.Visitor {

	if n == nil {
		return nil
	}

	switch n.(type) {

	// we are only interested in field types
	case *ast.Field:

		// comments after the field are stripped away by the grpc protoc-generator
		// therefore we need to check the lines above the field which are
		// contained in the commentgroup that is part of the field
		var commentAbove string

		// iterate through the sub-nodes of the field
		ast.Inspect(n, func(subn ast.Node) bool {

			// get the content of all comment groups in the field
			switch subd := subn.(type) {
			case *ast.CommentGroup:
				commentAbove = commentAbove + subd.Text()
			}

			return true

		})

		// find all tag expressions in the comment
		tagExpressions := tagExp.FindAllString(commentAbove, -1)

		// remove all ticks from expressions
		for i, value := range tagExpressions {
			tagExpressions[i] = strings.Trim(value, "`")
		}

		// join expressions as one string
		additionalTags := strings.Join(tagExpressions, " ")

		// tags are stored as subnodes of type ast.BasicLit
		ast.Inspect(n, func(subn ast.Node) bool {

			switch subd := subn.(type) {
			case *ast.BasicLit:

				// remove the ticks from the current value
				newTagValue := strings.Trim(subd.Value, "`")

				// add additional tags to the struct
				if newTagValue == "" {
					subd.Value = fmt.Sprintf("`%s`", additionalTags)
				} else {
					subd.Value = fmt.Sprintf("`%s %s`", newTagValue, additionalTags)
				}

			}

			return true
		})

	}

	return v

}

// tagExp will find tag expressions in the comment
var tagExp = regexp.MustCompile("`[a-z]*:.*`")
